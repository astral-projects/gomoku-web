package gomoku.services.game

import gomoku.domain.Id
import gomoku.domain.game.Game
import gomoku.domain.game.GameLogic
import gomoku.domain.game.GamePoints
import gomoku.domain.game.SystemInfo
import gomoku.domain.game.board.BoardDraw
import gomoku.domain.game.board.BoardRun
import gomoku.domain.game.board.BoardWin
import gomoku.domain.game.board.Player
import gomoku.domain.game.board.moves.move.Square
import gomoku.domain.game.variant.Variant
import gomoku.domain.game.variant.VariantConfig
import gomoku.domain.user.User
import gomoku.repository.GamesRepository
import gomoku.repository.transaction.TransactionManager
import gomoku.utils.Failure
import gomoku.utils.NotTested
import gomoku.utils.Success
import gomoku.utils.failure
import gomoku.utils.success
import kotlinx.datetime.Clock
import org.springframework.stereotype.Component
import org.springframework.stereotype.Service

@Service
class GamesService(
    private val transactionManager: TransactionManager,
    private val clock: Clock,
    private val variants: List<Variant>
) {

    /**
     * Maps ids generated by the database to the variants implemented in the code by the configuration name,
     * which is unique.
     */
    private val gameVariantMap: Map<Id, Variant> by lazy {
        transactionManager.run { transaction ->
            val variantsConfig: List<VariantConfig> = variants.map { it.config }
            transaction.gamesRepository.insertVariants(variantsConfig)
            val gameVariants = transaction.gamesRepository.getVariants()
            require(gameVariants.isNotEmpty()) { "No variants found in the database" }
            gameVariants.associateBy({ it.id }, { variants.first { v -> v.config.name === it.name } })
        }
    }

    init {
        gameVariantMap
    }

    @NotTested
    fun getGameById(id: Id): GettingGameResult {
        return transactionManager.run {
            when (val game = (it.gamesRepository.getGameById(id))) {
                null -> failure(GettingGameError.GameNotFound)
                else -> success(game)
            }
        }
    }

    fun findGame(variantId: Id, user: User): GameCreationResult =
        transactionManager.run { transaction ->
            val gamesRepository = transaction.gamesRepository
            val checkVariantId = gamesRepository.getVariantById(variantId)
                ?: return@run failure(GameCreationError.VariantNotFound)
            val variant = gameVariantMap[checkVariantId]
                ?: return@run failure(GameCreationError.VariantNotFound)
            val isAlreadyInGame = gamesRepository.findIfUserIsInGame(user.id)
            if (isAlreadyInGame == null) {
                val lobby = gamesRepository.isMatchmaking(checkVariantId, user.id)
                if (lobby != null) {
                    if (!gamesRepository.deleteUserFromLobby(lobby.lobbyId)) {
                        failure(GameCreationError.UserAlreadyInLobby)
                    } else {
                        val res = gamesRepository.createGame(
                            variantId = checkVariantId,
                            hostId = lobby.userId,
                            guestId = user.id,
                            lobbyId = lobby.lobbyId,
                            board = variant.initialBoard()
                        )
                        when (res) {
                            null -> failure(GameCreationError.UserAlreadyInGame)
                            else -> success("Joining game")
                        }

                    }
                } else {
                    val check = gamesRepository.checkIfUserIsInLobby(user.id)
                    if (check != null) {
                        failure(GameCreationError.UserAlreadyInLobby)
                    } else {
                        val r = gamesRepository.addUserToLobby(checkVariantId, user.id)
                        when (r) {
                            null -> failure(GameCreationError.VariantNotFound)
                            else -> success("Waiting in lobby")
                        }
                    }
                }
            } else {
                success("You already in the Game")
            }
        }

    fun deleteGame(gameId: Id, userId: Id): GamePutResult {
        return transactionManager.run { transaction ->
            val gamesRepository = transaction.gamesRepository
            val u = gamesRepository.userIsTheHost(gameId, userId)
            if (!u) {
                failure(GamePutError.UserIsNotTheHost)
            } else {
                val g = gamesRepository.deleteGame(gameId, userId)
                when (g) {
                    false -> failure(GamePutError.GameNotFound)
                    true -> success(g)
                }
            }
        }
    }

    fun getGameStatus(userId: Id, gameId: Id): GettingGameResult {
        return transactionManager.run { transaction ->
            val gamesRepository = transaction.gamesRepository
            when (val game = gamesRepository.getGameStatus(gameId, userId)) {
                null -> failure(GettingGameError.GameNotFound)
                else -> success(game)
            }
        }
    }

    fun getSystemInfo(): SystemInfo = SystemInfo

    @NotTested
    fun makeMove(gameId: Id, user: Id, square: Square, player: Player): GameMakeMoveResult =
        transactionManager.run { transaction ->
            val gamesRepository = transaction.gamesRepository
            val game = gamesRepository.getGameById(gameId)
                ?: return@run failure(GameMakeMoveError.GameNotFound)
            if (!gamesRepository.userBelongsToTheGame(user, gameId)) {
                return@run failure(GameMakeMoveError.UserDoesNotBelongToThisGame)
            }
            val variant = gameVariantMap[game.variant.id]
                ?: return@run failure(GameMakeMoveError.VariantNotFound)
            val gameLogic = GameLogic(variant, clock)
            when (val playLogic = gameLogic.play(square, game, user)) {
                is Failure -> failure(GameMakeMoveError.MoveNotValid(playLogic.value))
                is Success -> {
                    val updatedGame = playLogic.value
                    updatedPointsBasedOnBoardType(gamesRepository, variant.points, user, updatedGame)
                    when (val makeMove = gamesRepository.updateGame(gameId, updatedGame.board)) {
                        false -> failure(GameMakeMoveError.GameNotFound)
                        true -> success(makeMove)
                    }
                }
            }
        }

    @NotTested
    fun exitGame(gameId: Id, userId: Id): GameDeleteResult {
        return transactionManager.run { transaction ->
            val gamesRepository = transaction.gamesRepository
            val userBelongsToTheGame = gamesRepository.userBelongsToTheGame(userId, gameId)
            if (!userBelongsToTheGame) {
                return@run failure(GameDeleteError.UserDoesntBelongToThisGame)
            }
            val winner = gamesRepository.exitGame(gameId, userId)
            val game = gamesRepository.getGameById(gameId)
                ?: return@run failure(GameDeleteError.GameNotFound)
            val variant = gameVariantMap[game.variant.id]
                ?: return@run failure(GameDeleteError.VariantNotFound)
            success(
                gamesRepository.updatePoints(
                    gameId = gameId,
                    winnerId = winner,
                    loserId = if (userId == game.hostId) game.guestId else game.hostId,
                    winnerPoints = variant.points.onForfeitOrTimer.winner,
                    loserPoints = variant.points.onForfeitOrTimer.forfeiter,
                    shouldCountAsGameWin = false
                )
            )
        }
    }

    private fun updatedPointsBasedOnBoardType(
        gamesRepository: GamesRepository,
        gamePoints: GamePoints,
        userId: Id,
        game: Game
    ): Boolean = when (game.board) {
        is BoardWin -> {
            gamesRepository.updatePoints(
                gameId = game.id,
                winnerId = userId,
                loserId = if (userId == game.hostId) game.guestId else game.hostId,
                winnerPoints = gamePoints.onFinish.winner,
                loserPoints = gamePoints.onFinish.loser,
                shouldCountAsGameWin = true
            )
        }

        is BoardDraw -> {
            gamesRepository.updatePoints(
                gameId = game.id,
                winnerId = userId,
                loserId = if (userId == game.hostId) game.guestId else game.hostId,
                winnerPoints = gamePoints.onDraw.shared,
                loserPoints = gamePoints.onDraw.shared,
                shouldCountAsGameWin = false
            )
        }

        is BoardRun -> true
    }

}


