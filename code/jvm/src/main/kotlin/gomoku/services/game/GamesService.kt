package gomoku.services.game

import gomoku.domain.components.Id
import gomoku.domain.game.Game
import gomoku.domain.game.GameLogic
import gomoku.domain.game.GamePoints
import gomoku.domain.game.GameState
import gomoku.domain.game.board.BoardDraw
import gomoku.domain.game.board.BoardRun
import gomoku.domain.game.board.BoardWin
import gomoku.domain.game.board.moves.move.Square
import gomoku.domain.game.variant.GameVariant
import gomoku.domain.game.variant.Variant
import gomoku.domain.game.variant.config.VariantConfig
import gomoku.repository.GamesRepository
import gomoku.repository.transaction.TransactionManager
import gomoku.utils.Failure
import gomoku.utils.Success
import gomoku.utils.failure
import gomoku.utils.success
import kotlinx.datetime.Clock
import org.springframework.stereotype.Service

@Service
class GamesService(
    val transactionManager: TransactionManager,
    private val clock: Clock,
    private val variants: List<Variant>
) {

    /**
     * Maps ids generated by the database to the variants implemented in the code by the configuration name,
     * which is unique.
     */
    private val gameVariantMap: Map<Id, Variant> by lazy {
        transactionManager.run { transaction ->
            val variantsConfig: List<VariantConfig> = variants.map { it.config }
            transaction.gamesRepository.insertVariants(variantsConfig)
            val gameVariants = transaction.gamesRepository.getVariants()
            if (gameVariants.isEmpty()) {
                throw NoVariantImplementationFoundException("No variants found in the database")
            }
            gameVariants.associateBy({ it.id }, { variants.first { v -> v.config.name === it.name } })
        }
    }

    init {
        // force initialization
        gameVariantMap
    }

    /**
     * Retrieves a game by its id.
     * @param gameId the id of the game to retrieve.
     */
    fun getGameById(gameId: Id): GettingGameResult =
        transactionManager.run { transaction ->
            when (val game = (transaction.gamesRepository.getGameById(gameId))) {
                null -> failure(GettingGameError.GameNotFound)
                else -> success(game)
            }
        }

    /**
     * Creates a game with the given variant and the given user as the host.
     *
     * **Returns an error**, when:
     * - The variant is not found;
     * - The user is already in a game;
     * - The user is still in a lobby;
     * - The user was not in the lobby when the lobby was going to be deleted.
     * - The game was not created correctly.
     *
     * **Returns success**, when:
     * - The game was created successfully;
     * - The lobby was created successfully;
     * - The user is already in a lobby, and must wait for an opponent.
     * @param variantId the id of the variant to search or create a game with.
     * @param userId the id of to user to be associated with the game.
     */
    fun findGame(variantId: Id, userId: Id): GameCreationResult =
        transactionManager.run { transaction ->
            val gamesRepository = transaction.gamesRepository
            val variant = gameVariantMap[variantId]
                ?: return@run failure(GameCreationError.VariantNotFound)
            val waitingLobby = gamesRepository.checkIfUserIsInLobby(userId)
            if (waitingLobby != null) {
                return@run success(FindGameSuccess.StillInLobby(waitingLobby.lobbyId))
            }
            val game = gamesRepository.findIfUserIsInGame(userId)
            if (game == null) {
                val lobby = gamesRepository.isMatchmaking(variantId, userId)
                if (lobby != null) {
                    if (!gamesRepository.deleteUserFromLobby(lobby.lobbyId)) {
                        failure(GameCreationError.UserAlreadyLeftTheLobby(lobby.lobbyId))
                    } else {
                        val gameId = gamesRepository.createGame(
                            variantId = variantId,
                            hostId = lobby.userId,
                            guestId = userId,
                            lobbyId = lobby.lobbyId,
                            board = variant.initialBoard()
                        )
                        when (gameId) {
                            null -> failure(GameCreationError.GameInsertionError)
                            else -> success(FindGameSuccess.GameMatch(gameId))
                        }
                    }
                } else {
                    when (val lobbyId = gamesRepository.addUserToLobby(variantId, userId)) {
                        null -> failure(GameCreationError.LobbyNotFound)
                        else -> success(FindGameSuccess.LobbyCreated(lobbyId))
                    }
                }
            } else {
                failure(GameCreationError.UserAlreadyInGame(game.id))
            }
        }

    /**
     * Deletes the game with the given id if the user is the host and the game is not in progress.
     *
     * **Returns an error**, when:
     * - The game is not found;
     * - The user is not the host;
     * - The game is in progress;
     * @param gameId the id of the game to delete.
     * @param userId the id of the user requesting the deletion.
     */
    fun deleteGame(gameId: Id, userId: Id): GameDeleteResult =
        transactionManager.run { transaction ->
            val gamesRepository = transaction.gamesRepository
            val game = gamesRepository.getGameById(gameId)
                ?: return@run failure(GameDeleteError.GameNotFound)
            if (game.hostId != userId) {
                return@run failure(GameDeleteError.UserIsNotTheHost)
            }
            if (game.state != GameState.IN_PROGRESS) {
                return@run failure(GameDeleteError.GameIsInprogress)
            }
            when (gamesRepository.deleteGame(gameId, userId)) {
                false -> failure(GameDeleteError.GameNotFound)
                true -> success(true)
            }
        }

    /**
     * Makes a move in the game, passing the user id and the move.
     * If the user does not belong to the game, returns an error.
     * If the move is not valid, returns an error.
     * If the game is not found, returns an error.
     * Depending on the board type, updates the points of the players.Using function updatedPointsBasedOnBoardType
     * Finally, returns the updated game.Or returns an error
     */
    fun makeMove(gameId: Id, userId: Id, square: Square): GameMakeMoveResult =
        transactionManager.run { transaction ->
            val gamesRepository = transaction.gamesRepository
            val game = gamesRepository.getGameById(gameId)
                ?: return@run failure(GameMakeMoveError.GameNotFound)
            if (game.hostId != userId && game.guestId != userId) {
                return@run failure(GameMakeMoveError.UserNotInGame)
            }
            gamesRepository.userBelongsToTheGame(userId, gameId)
                ?: return@run failure(GameMakeMoveError.UserDoesNotBelongToThisGame)
            val variant = gameVariantMap[game.variant.id]
                ?: return@run failure(GameMakeMoveError.VariantNotFound)
            val gameLogic = GameLogic(variant, clock)
            when (val playLogic = gameLogic.play(game, userId, square)) {
                is Failure -> failure(GameMakeMoveError.MoveNotValid(playLogic.value))
                is Success -> {
                    val updatedGame = playLogic.value
                    updatedPointsBasedOnBoardType(gamesRepository, variant.points, userId, updatedGame)
                    when (gamesRepository.updateGame(gameId, updatedGame.board)) {
                        false -> failure(GameMakeMoveError.GameNotFound)
                        true -> success(true)
                    }
                }
            }
        }

    /**
     * Exits the game with the given id if the user belongs to the game.
     *
     * **Returns an error**, when:
     * - The game is not found;
     * - The user is not in the game;
     * - The game is already finished;
     * - The variant is not found.
     * @param gameId the id of the game to exit.
     * @param userId the id of the user that requests the exit.
     */
    fun exitGame(gameId: Id, userId: Id): GameUpdateResult {
        return transactionManager.run { transaction ->
            val gamesRepository = transaction.gamesRepository
            val game = gamesRepository.getGameById(gameId)
                ?: return@run failure(GameUpdateError.GameNotFound)
            if (game.hostId != userId && game.guestId != userId) {
                return@run failure(GameUpdateError.UserDoesntBelongToThisGame)
            }
            val winner = gamesRepository.exitGame(gameId, userId)
            if (winner != null) {
                val variant = gameVariantMap[game.variant.id]
                    ?: return@run failure(GameUpdateError.VariantNotFound)
                success(
                    gamesRepository.updatePoints(
                        winnerId = winner,
                        loserId = userId,
                        winnerPoints = variant.points.onForfeitOrTimer.winner,
                        loserPoints = variant.points.onForfeitOrTimer.forfeiter,
                        shouldCountAsGameWin = true
                    )
                )
            } else {
                failure(GameUpdateError.GameAlreadyFinished)
            }
        }
    }

    /**
     * Enables a user to wait for a game within a lobby.
     *
     * **Returns an error**, when:
     * - The user is not in a lobby;
     * - The user is not in the lobby with the given id.
     * @param lobbyId the id of the lobby where the user is waiting.
     * @param userId the id of the user to wait for a game.
     */
    fun waitForGame(lobbyId: Id, userId: Id): GameWaitResult =
        transactionManager.run { transaction ->
            val gamesRepository = transaction.gamesRepository
            val lobby = gamesRepository.checkIfUserIsInLobby(userId)
            if (lobby != null) {
                if (lobby.lobbyId != lobbyId) {
                    return@run failure(GameWaitError.UserNotInLobby)
                }
                return@run success(WaitForGameSuccess.WaitingInLobby(lobby.lobbyId))
            }
            val foundLobby = gamesRepository.waitForGame(lobbyId, userId)
                ?: return@run failure(GameWaitError.UserNotInAnyGameOrLobby)
            success(WaitForGameSuccess.GameMatch(foundLobby))
        }

    /**
     * Exits the lobby with the given id if the user belongs to the lobby.
     *
     * **Returns an error**, when:
     * - The lobby is not found;
     * @param lobbyId the id of the lobby to exit.
     * @param userId the id of the user to exit the lobby.
     */
    fun exitLobby(lobbyId: Id, userId: Id): LobbyDeleteResult =
        transactionManager.run { transaction ->
            val gamesRepository = transaction.gamesRepository
            gamesRepository.checkIfUserIsInLobby(userId)
                ?: return@run failure(LobbyDeleteError.LobbyNotFound)
            when (gamesRepository.deleteLobby(lobbyId, userId)) {
                false -> failure(LobbyDeleteError.LobbyNotFound)
                true -> success(true)
            }
        }

    /**
     * Retrieves the list of variants available in the game.
     */
    fun getVariants(): List<GameVariant> =
        gameVariantMap.map {
            GameVariant(it.key, it.value.config.name, it.value.config.openingRule, it.value.config.boardSize)
        }

    /**
     * Updates the points of the game based on the board type.
     *
     * @param gamesRepository the repository to update the points.
     * @param gamePoints the points of the game.
     * @param userId the id of the user to update the points.
     * @param game the game to update the points.
     * @return true if the points were updated successfully, false otherwise.
     */
    private fun updatedPointsBasedOnBoardType(
        gamesRepository: GamesRepository,
        gamePoints: GamePoints,
        userId: Id,
        game: Game
    ): Boolean = when (game.board) {
        is BoardWin -> {
            gamesRepository.updatePoints(
                winnerId = userId,
                loserId = if (userId == game.hostId) game.guestId else game.hostId,
                winnerPoints = gamePoints.onFinish.winner,
                loserPoints = gamePoints.onFinish.loser,
                shouldCountAsGameWin = true
            )
        }

        is BoardDraw -> {
            gamesRepository.updatePoints(
                winnerId = userId,
                loserId = getOtherPlayer(game, userId),
                winnerPoints = gamePoints.onDraw.shared,
                loserPoints = gamePoints.onDraw.shared,
                shouldCountAsGameWin = false
            )
        }

        is BoardRun -> true
    }

    /**
     * Gets the opponent in the game.
     *
     * @param game the game to get the opponent.
     * @param userId the id of the user to get the opponent.
     */
    private fun getOtherPlayer(game: Game, userId: Id) =
        if (game.hostId == userId) game.guestId else game.hostId
}
