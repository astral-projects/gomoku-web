package gomoku.services.game

import gomoku.domain.components.Id
import gomoku.domain.game.Game
import gomoku.domain.game.GameLogic
import gomoku.domain.game.GameLogic.Companion.toPlayer
import gomoku.domain.game.GamePoints
import gomoku.domain.game.GameState
import gomoku.domain.game.board.BoardDraw
import gomoku.domain.game.board.BoardRun
import gomoku.domain.game.board.BoardWin
import gomoku.domain.game.board.moves.move.Square
import gomoku.domain.game.variant.GameVariant
import gomoku.domain.game.variant.Variant
import gomoku.domain.game.variant.config.VariantConfig
import gomoku.repository.GamesRepository
import gomoku.repository.transaction.TransactionManager
import gomoku.utils.Failure
import gomoku.utils.Success
import gomoku.utils.failure
import gomoku.utils.success
import kotlinx.datetime.Clock
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import java.sql.Connection.TRANSACTION_SERIALIZABLE

@Service
class GamesService(
    private val transactionManager: TransactionManager,
    private val clock: Clock,
    private val variants: List<Variant>,
) {

    /**
     * Maps ids generated by the database to the variants implemented in the code by the configuration name,
     * which is unique.
     * Only the received variants in [variants] are mapped, which means that, even if
     * there are other variants in the database, only the ones received in the constructor are mapped.
     */
    private val gameVariantMap: Map<Id, Variant> by lazy {
        transactionManager.run { transaction ->
            logger.info("Inserting variants into the database")
            val variantsConfig: List<VariantConfig> = variants.map { it.config }
            transaction.gamesRepository.insertVariants(variantsConfig)
            val gameVariants: List<GameVariant> = transaction.gamesRepository.getVariants()
            if (gameVariants.isEmpty()) {
                logger.error("No variants found in the database")
                throw NoVariantImplementationFoundException("No variants found in the database")
            }
            // only return variants received in the constructor even if
            // there are more variants in the database
            variants.associateBy { variant ->
                gameVariants.first { it.name == variant.config.name }.id
            }
        }
    }

    init {
        if (variants.isEmpty()) {
            logger.error("No variants implementations found in the code")
            throw NoVariantImplementationFoundException("No variants implementations found in the code")
        }
        // force initialization
        gameVariantMap
    }

    /**
     * Retrieves a game by its id.
     *
     * **Returns an error**, when:
     * - The game is not found.
     * @param gameId the id of the game to retrieve.
     *
     */
    fun getGameById(gameId: Id): GettingGameResult =
        transactionManager.run { transaction ->
            transaction.setIsolationLevel(TRANSACTION_SERIALIZABLE)
            when (val game = (transaction.gamesRepository.getGameById(gameId))) {
                null -> failure(GettingGameError.GameNotFound)
                else -> success(game)
            }
        }

    /**
     * Creates a game with the given variant and the given user as the host.
     *
     * **Returns an error**, when:
     * - The variant is not found;
     * - The user was not in the lobby when the lobby was going to be deleted.
     * - The game was not created correctly.
     *
     * **Returns success**, when:
     * - The game was created successfully;
     * - The lobby was created successfully;
     * @param variantId the id of the variant to search or create a game with.
     * @param userId the id of to user to be associated with the game.
     */
    fun findGame(variantId: Id, userId: Id): GameCreationResult =
        transactionManager.run { transaction ->
            transaction.setIsolationLevel(TRANSACTION_SERIALIZABLE)
            val gamesRepository = transaction.gamesRepository
            val variant = gameVariantMap[variantId]
                ?: return@run failure(GameCreationError.VariantNotFound)
            val lobby = gamesRepository.isMatchmaking(variantId, guestId = userId)
            if (lobby != null) {
                logger.info("Host '$userId' was waiting for a game in lobby(id='${lobby.lobbyId}', variantId='$variantId')")
                if (!gamesRepository.deleteUserFromLobby(lobby.lobbyId)) {
                    logger.info("Deleted host '$userId' from lobby(id='${lobby.lobbyId}')")
                    failure(GameCreationError.UserAlreadyLeftTheLobby(lobby.lobbyId))
                } else {
                    val gameId = gamesRepository.createGame(
                        variantId = variantId,
                        hostId = lobby.userId,
                        guestId = userId,
                        lobbyId = lobby.lobbyId,
                        board = variant.initialBoard()
                    )
                    when (gameId) {
                        null -> failure(GameCreationError.GameInsertionError)
                        else -> {
                            logger.info("Created game(id='$gameId') for guest '$userId' and host '${lobby.userId}'")
                            success(FindGameSuccess.GameMatch(gameId.value))
                        }
                    }
                }
            } else {
                when (val lobbyId = gamesRepository.addUserToLobby(variantId, userId)) {
                    null -> failure(GameCreationError.LobbyNotFound)
                    else -> {
                        logger.info("Created lobby(id='$lobbyId') for host user '$userId'")
                        success(FindGameSuccess.LobbyCreated(lobbyId.value))
                    }
                }
            }
        }

    /**
     * Deletes the game with the given id if the user is the host and the game is not in progress.
     *
     * **Returns an error**, when:
     * - The game is not found;
     * - The user is not the host;
     * - The game is in progress;
     * @param gameId the id of the game to delete.
     * @param userId the id of the user requesting the deletion.
     */
    fun deleteGame(gameId: Id, userId: Id): GameDeleteResult =
        transactionManager.run { transaction ->
            transaction.setIsolationLevel(TRANSACTION_SERIALIZABLE)
            val gamesRepository = transaction.gamesRepository
            val game = gamesRepository.getGameById(gameId)
                ?: return@run failure(GameDeleteError.GameNotFound)
            if (game.hostId != userId) {
                return@run failure(GameDeleteError.UserIsNotTheHost)
            }
            if (game.state == GameState.IN_PROGRESS) {
                return@run failure(GameDeleteError.GameIsInProgress)
            }
            when (gamesRepository.deleteGame(gameId, userId)) {
                false -> failure(GameDeleteError.GameNotFound)
                true -> success(true)
            }
        }

    /**
     * Makes a move in the game.
     *
     * **Returns an error**, when:
     * - The game is not found;
     * - The user is not in the game;
     * - The move is not valid.
     *
     * Depending on the board type, updates the points of the players using [updatedPointsBasedOnBoardType] function.
     * @param gameId the id of the game.
     * @param userId the id of the user that wants to make the move.
     * @param toSquare the square to make the move to.
     */
    fun makeMove(gameId: Id, userId: Id, toSquare: Square): GameMakeMoveResult =
        transactionManager.run { transaction ->
            transaction.setIsolationLevel(TRANSACTION_SERIALIZABLE)
            val gamesRepository = transaction.gamesRepository
            val game = gamesRepository.getGameById(gameId)
                ?: return@run failure(GameMakeMoveError.GameNotFound)
            if (game.hostId != userId && game.guestId != userId) {
                return@run failure(GameMakeMoveError.UserNotInGame)
            }
            val variant = gameVariantMap[game.variant.id]
                ?: return@run failure(GameMakeMoveError.VariantNotFound)
            val gameLogic = GameLogic(variant, clock)
            when (val playLogic = gameLogic.play(game, userId, toSquare)) {
                is Failure -> failure(GameMakeMoveError.MoveNotValid(playLogic.value))
                is Success -> {
                    val updatedGame = playLogic.value
                    updatedPointsBasedOnBoardType(gamesRepository, variant.points, userId, updatedGame)
                    when (gamesRepository.updateGame(gameId, updatedGame.board)) {
                        false -> failure(GameMakeMoveError.GameNotFound)
                        true -> success(true)
                    }
                }
            }
        }

    /**
     * Exits the game with the given id if the user belongs to the game.
     *
     * **Returns an error**, when:
     * - The game is not found;
     * - The user is not in the game;
     * - The game is already finished;
     * - The variant is not found.
     * @param gameId the id of the game to exit.
     * @param userId the id of the user that requests the exit.
     */
    fun exitGame(gameId: Id, userId: Id): GameUpdateResult =
        transactionManager.run { transaction ->
            transaction.setIsolationLevel(TRANSACTION_SERIALIZABLE)
            val gamesRepository = transaction.gamesRepository
            val game = gamesRepository.getGameById(gameId)
                ?: return@run failure(GameUpdateError.GameNotFound)
            if (game.hostId != userId && game.guestId != userId) {
                return@run failure(GameUpdateError.UserNotInGame)
            }
            val winnerId = gamesRepository.exitGame(gameId, userId)
            if (winnerId != null) {
                val variant = gameVariantMap[game.variant.id]
                    ?: return@run failure(GameUpdateError.VariantNotFound)
                gamesRepository.updateGame(gameId, BoardWin(game.board.grid, winnerId.toPlayer(game)))
                success(
                    gamesRepository.updatePoints(
                        winnerId = winnerId,
                        loserId = userId,
                        winnerPoints = variant.points.onForfeitOrTimer.winner,
                        loserPoints = variant.points.onForfeitOrTimer.forfeiter,
                        shouldCountAsGameWin = true
                    )
                )
            } else {
                failure(GameUpdateError.GameAlreadyFinished)
            }
        }

    /**
     * Enables a user to wait for a game within a lobby.
     *
     * **Returns an error**, when:
     * - The user is not in a lobby;
     * - The user is not in the lobby with the given id.
     * @param lobbyId the id of the lobby where the user is waiting.
     * @param userId the id of the user to wait for a game.
     */
    fun waitForGame(lobbyId: Id, userId: Id): GameWaitResult =
        transactionManager.run { transaction ->
            transaction.setIsolationLevel(TRANSACTION_SERIALIZABLE)
            val gamesRepository = transaction.gamesRepository
            val lobbies = gamesRepository.getUserLobbies(userId)
            val lobby = lobbies.firstOrNull { it.lobbyId == lobbyId }
            if (lobby != null) {
                return@run success(WaitForGameSuccess.WaitingInLobby(lobby.lobbyId.value))
            }
            val gameId = gamesRepository.waitForGame(lobbyId, userId)
                ?: return@run failure(GameWaitError.UserNotInAnyGameOrLobby)
            success(WaitForGameSuccess.GameMatch(gameId.value))
        }

    /**
     * Exits the lobby with the given id if the user is in the lobby.
     *
     * **Returns an error**, when:
     * - The lobby is not found;
     * @param lobbyId the id of the lobby to exit.
     * @param userId the id of the user to exit the lobby.
     */
    fun exitLobby(lobbyId: Id, userId: Id): LobbyDeleteResult =
        transactionManager.run { transaction ->
            transaction.setIsolationLevel(TRANSACTION_SERIALIZABLE)
            val gamesRepository = transaction.gamesRepository
            val lobbies = gamesRepository.getUserLobbies(userId)
            lobbies.firstOrNull { it.lobbyId == lobbyId }
                ?: return@run failure(LobbyDeleteError.LobbyNotFound)
            when (gamesRepository.deleteLobby(lobbyId, userId)) {
                false -> failure(LobbyDeleteError.LobbyNotFound)
                true -> success(true)
            }
        }

    /**
     * Retrieves the list of variants available in the game.
     */
    fun getVariants(): List<GameVariant> =
        gameVariantMap.map {
            GameVariant(it.key, it.value.config.name, it.value.config.openingRule, it.value.config.boardSize)
        }

    /**
     * Updates the points of the game based on the board type.
     *
     * @param gamesRepository the repository to update the points.
     * @param gamePoints the points of the game.
     * @param userId the id of the user to update the points.
     * @param game the game to update the points.
     * @return true if the points were updated successfully, false otherwise.
     */
    private fun updatedPointsBasedOnBoardType(
        gamesRepository: GamesRepository,
        gamePoints: GamePoints,
        userId: Id,
        game: Game
    ): Boolean = when (game.board) {
        is BoardWin -> {
            gamesRepository.updatePoints(
                winnerId = userId,
                loserId = if (userId == game.hostId) game.guestId else game.hostId,
                winnerPoints = gamePoints.onFinish.winner,
                loserPoints = gamePoints.onFinish.loser,
                shouldCountAsGameWin = true
            )
        }

        is BoardDraw -> {
            gamesRepository.updatePoints(
                winnerId = userId,
                loserId = getOtherPlayer(game, userId),
                winnerPoints = gamePoints.onDraw.shared,
                loserPoints = gamePoints.onDraw.shared,
                shouldCountAsGameWin = false
            )
        }

        is BoardRun -> true
    }

    /**
     * Gets the opponent in the game.
     *
     * @param game the game to get the opponent.
     * @param userId the id of the user to get the opponent.
     */
    private fun getOtherPlayer(game: Game, userId: Id) =
        if (game.hostId == userId) game.guestId else game.hostId

    companion object {
        private val logger = LoggerFactory.getLogger(GamesService::class.java)
    }
}
